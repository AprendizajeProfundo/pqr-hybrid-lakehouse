# SPEC-0016.1 — Generación de Datos Sintéticos PQRS (V1)

**Versión:** 1.0  
**Fecha:** 2026-02-25  
**Deriva de:** ADR-0016, SPEC-0016  

---

# 1. OBJETIVO

Definir un proceso determinista para generar datos sintéticos que simulen el ciclo completo de vida de PQRS basados en emails y otros canales. Los datos deben cubrir desde la recepción de correos hasta el seguimiento en bases de datos, habilitando dashboards analíticos completos.

El output incluye:
- Eventos raw en JSONL (simulando emails y interacciones).
- Tablas curadas en Silver (tickets, messages, status events).
- KPIs en Gold (volumen, backlog, SLA).
- Población en Postgres para serving.

---

# 2. REQUISITOS GENERALES

## 2.1 Determinismo
- Input: `seed` (entero), `date_range` (inicio-fin), `run_id` (UUID).
- Output reproducible: mismos datos en re-runs con mismos parámetros.
- Usar librerías como `faker`, `numpy.random` con seed fijo.

## 2.2 Distribución Realista
- **Volumen diario:** 50-200 tickets (configurable via config).
- **Canales:** email (40%), webform (30%), chat (20%), call (10%).
- **Tipos PQRS:** P (30%), Q (25%), R (30%), S (15%).
- **Prioridades:** alta (10%), media (50%), baja (40%).
- **Regiones:** Basado en datos reales de Colombia (Bogotá 20%, Antioquia 15%, etc.).
- **SLA breach:** 7-12% de tickets vencidos.

## 2.3 Cobertura del Proceso
- Simular recepción de emails (con subject, body, attachments).
- Generar respuestas automáticas/sintéticas.
- Transiciones de estado según máquina de estados (pqrs_status_v1.yaml).
- Cálculo de SLA y métricas.

---

# 3. MODELO DE DATOS SINTÉTICO

## 3.1 Entidades Principales
- **Ticket:** Caso PQRS único.
- **Message:** Interacciones (email inicial + respuestas).
- **StatusEvent:** Cambios de estado.
- **Attachment:** Adjuntos simulados.

## 3.2 Atributos por Entidad

### Ticket
- `ticket_id`: UUID
- `external_id`: ID público (e.g., "PQRS-2026-001")
- `source_channel`: email/webform/chat/call
- `pqrs_type`: P/Q/R/S (clasificado sintéticamente)
- `priority`: alta/media/baja
- `geo_region`: Región (e.g., "Cundinamarca")
- `geo_municipio`: Municipio
- `created_at`: Timestamp inicial
- `sla_due_at`: Fecha límite SLA (calculado)

### Message
- `message_id`: UUID
- `ticket_id`: FK
- `ts`: Timestamp
- `role`: citizen/agent
- `text`: Contenido del email/mensaje
- `text_len`: Longitud del texto

### StatusEvent
- `event_id`: UUID
- `ticket_id`: FK
- `ts`: Timestamp
- `status_from`: Estado anterior
- `status_to`: Estado nuevo
- `actor_role`: system/agent

### Attachment
- `attachment_id`: UUID
- `ticket_id`: FK
- `ts`: Timestamp
- `file_type`: pdf/jpg/etc.
- `size_kb`: Tamaño simulado
- `source_channel`: Canal

---

# 4. ALGORITMO DE GENERACIÓN

## 4.1 Paso 1: Generar Tickets Base
- Para cada día en `date_range`:
  - Calcular volumen diario (usando distribución normal con seed).
  - Asignar canales, tipos, prioridades, geo según probabilidades.
  - Crear `ticket_id`, `external_id`, `created_at` (distribuido en el día).
  - Clasificar tipo/prioridad usando reglas sintéticas (basado en pqrs_preclass_rules_v1.yaml).

## 4.2 Paso 2: Generar Mensajes (Emails)
- Para cada ticket:
  - **Email inicial (citizen):** Generar subject/body realista usando Faker.
    - Subject: Basado en tipo (e.g., "Solicito información sobre..." para P).
    - Body: Texto largo con quejas/solicitudes.
    - Attachments: 0-3 archivos simulados (pdf, jpg, etc.).
  - **Respuestas (agent):** 1-5 respuestas con delays realistas (horas/días).
    - Texto: Respuestas estándar o sintéticas.
    - Cambios de estado asociados.

## 4.3 Paso 3: Generar Transiciones de Estado
- Usar máquina de estados de pqrs_status_v1.yaml.
- Secuencia típica: RECEIVED → RADICATED → CLASSIFIED → ASSIGNED → IN_PROGRESS → RESPONDED → CLOSED.
- Timestamps: Con delays basados en SLA (e.g., RADICATED en 1-4 horas).
- Algunos tickets: ON_HOLD, REOPENED para realismo.
- Calcular SLA: Inicia en RADICATED, pausa en ON_HOLD, etc.

## 4.4 Paso 4: Generar Eventos Raw
- Convertir todo a eventos JSONL según RAW-PQRS.schema.json.
- Estructura: Un evento por acción (ticket_created, message_added, status_changed, attachment_added).
- Incluir metadata: run_id, day.

## 4.5 Paso 5: Raw → Bronze
- Leer eventos JSONL de Raw.
- Validar contra esquema JSON.
- Normalización ligera: convertir a Parquet tipado, corregir timestamps, eliminar duplicados.
- Output: `bronze/pqrs_events/source=<source>/day=YYYY-MM-DD/run_id=<RUN_ID>/part-*.parquet`
- Checks: no duplicados, timestamps válidos, tipos correctos.

## 4.6 Paso 6: Bronze → Silver
- Desnormalizar eventos Parquet en tablas curadas.
- Enriquecer con dimensiones (geo, channel).
- Validar transiciones de estado contra pqrs_status_v1.yaml.
- Calcular SLA basado en sla_behavior.

## 4.7 Paso 7: Silver → Gold
- Agregaciones diarias: volumen, backlog, SLA.
- Materializar en Parquet y preparar para carga.

## 4.8 Paso 8: Poblar Postgres
- Cargar Silver y Gold a Supabase.
- Insertar en meta.etl_runs con estadísticas del run.

---

# 5. VALIDACIONES Y CALIDAD

- **Sintácticas:** Validar contra esquemas JSON/Parquet.
- **Semánticas:** Transiciones válidas, SLA correcto, no duplicados.
- **Distribuciones:** Verificar proporciones (e.g., 40% email).
- **Reproducibilidad:** Checksums de archivos deben coincidir en re-runs.

---

# 6. CONFIGURACIÓN

Archivo: `configs/pqrs_simulation_v1.yaml`

```yaml
seed: 42
date_range:
  start: "2026-01-01"
  end: "2026-01-31"
volume_daily_avg: 100
channel_probs:
  email: 0.4
  webform: 0.3
  chat: 0.2
  call: 0.1
pqrs_type_probs:
  P: 0.3
  Q: 0.25
  R: 0.3
  S: 0.15
sla_breach_rate: 0.1
geo_regions: ["Bogotá", "Antioquia", "Valle del Cauca", ...]
```

---

# 7. OUTPUT ESPERADO

- **Archivos S3/RustFS:** Raw JSONL, Bronze/Silver/Gold Parquet.
- **Postgres:** Tablas pobladas con datos del mes simulado.
- **Métricas:** Dashboard-ready con volumen, SLA, backlog por día.

---

# 8. CRITERIO DE ACEPTACIÓN

- Run completo en < 5 min para 1 mes.
- 100% cobertura de tickets con emails simulados.
- Dashboards funcionales en Streamlit/Metabase.
- Re-runs idénticos.